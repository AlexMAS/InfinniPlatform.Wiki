---
layout: default
title: ElasticSearch: техника построения запросов
position: 2
categories: 
tags: 
---

<h3>Введение</h3><p>&nbsp;</p><p>ElasticSearch представляет собой инструмент для индексации и хранения данных. Любая информация, которая может быть представлена в формате JSON, может быть сохранена и проиндексирована с использованием ElasticSearch. Цель данного документа &ndash; проиллюстрировать технику выполнения запросов к данным, проиндексированным в хранилище ElasticSearch.</p><h3>Клиент ElasticSearch для С#</h3><p>Представленные примеры выполнены с использованием клиента <a href="https://github.com/Mpdreamz/NEST">NEST</a>. NEST &ndash; C# клиент для ElasticSearch, который упрощает формирование запросов. Структура запросов, написанных с применением NEST, полностью соответствует структуре запросов ElasticSearch. Например, следующий запрос NEST на C#:</p><ac:structured-macro ac:name="code"><ac:plain-text-body><![CDATA[var s = new SearchDescriptor<ElasticSearchProject>()
                           .From(0)
                           .Size(10)
                           .Query(q => q
                                  .Text(t => t
                                        .OnField(f => f.Name)
                                        .QueryString("this is a test")
                                        .Fuzziness(1.0)
                                        .Analyzer("my_analyzer")
                                        .PrefixLength(2)
                                  )
                    );]]></ac:plain-text-body></ac:structured-macro><p><span>после сериализации будет соответствовать JSON строке:</span></p><ac:structured-macro ac:name="code"><ac:plain-text-body><![CDATA[		    { from: 0, size: 10, 
				query : {
					text: {
						name : { 
							query : "this is a test",
							analyzer : "my_analyzer",
							fuzziness: 1.0,
							prefix_length: 2
						}
					}
				}
			}]]></ac:plain-text-body></ac:structured-macro><h3><span>Поиск данных по строке</span></h3><p>Наиболее распространенным является поиск элементов по строке. Рассмотрим несколько примеров выполнения такого поиска в ElasticSearch.&nbsp;</p><p><span>Допустим, мы проиндексировали информацию о нескольких школах. Школа характеризуется уникальным именем, адресом, имеет директора и учеников.&nbsp;</span><span>Требуется найти все школы, расположенные на определенной улице. Запрос будет выглядеть следующим образом:</span></p><ac:structured-macro ac:name="code"><ac:plain-text-body><![CDATA[            var queryTypefied = _client.Search<School>(s => s
                .Filter(q => q
                    .Term(t => t.Street, "Kirova".ToLowerInvariant())
                )
            );

            var query = _client.Search(s => s
                .Filter(q => q
                    .Term("street", "Kirova".ToLowerInvariant())
                )
            );]]></ac:plain-text-body></ac:structured-macro><p>Здесь и далее представлены два варианта запроса - типизированный (тип проиндексированного объекта задан) и нетипизированный (ведется работа с объектами JObject или dynamic). Значение искомого терма обязательно должно быть в нижнем регистре.</p><p>В запросе может содержаться обращение к свойству какого-либо поля. Например, следующий запрос позволит найти все школы, директором в которых является человек с определенной фамилией:&nbsp;</p><ac:structured-macro ac:name="code"><ac:plain-text-body><![CDATA[            var queryTypefied = _client.Search<School>(s => s
                .Filter(q => q
                    .Term(t => t.Principal.LastName, "Monakhov".ToLowerInvariant())
                )
            );

            var query = _client.Search(s => s
                .Filter(q => q
                    .Term("principal.lastName", "Monakhov".ToLowerInvariant())
                )
            );]]></ac:plain-text-body></ac:structured-macro><p><span>ElasticSearch поддерживает поиск по начальной части слова. Например, запрос для поиска школы, в которой адрес начинается с определенной последовательности символов, будет выглядеть следующим образом:</span></p><ac:structured-macro ac:name="code"><ac:plain-text-body><![CDATA[            var queryTypefied = _client.Search<School>(s => s
                .Query(q => q
                    .TextPhrasePrefix(t=>t
                        .OnField(f=>f.Street)
                        .QueryString("kir")
                     )
                )
            );

            var query = _client.Search(s => s
                .Query(q => q
                    .TextPhrasePrefix(t => t
                        .OnField("street")
                        .QueryString("kir")
                     )
                )
            );]]></ac:plain-text-body></ac:structured-macro><p><span>Другой разновидностью поиска, когда строка полностью не известна, является поиск с применением wildcard выражений. В wildcard выражениях, символ * заменяет любое количество символов, символ ? заменяет 1 любой символ. Пример поиска школы, в которой адрес содержит определенный набор символов:</span></p><ac:structured-macro ac:name="code"><ac:plain-text-body><![CDATA[            var queryTypefied = _client.Search<School>(s => s
                .Query(q => q
                    .Wildcard(f => f.Street, "*rov?")
                )
            );

            var query = _client.Search(s => s
                .Query(q => q
                    .Wildcard("street", "*rov?")
                )
            );]]></ac:plain-text-body></ac:structured-macro><p><span>ElasticSearch поддерживает поиск по &laquo;близким&raquo; словам. Для определения степени &laquo;похожести&raquo; двух строк применяется понятие &laquo;расстояние Левенштейна&raquo; (минимальное количество вставок, замен и удалений символов, необходимое для преобразования одной строки в другую). Применение данных запросов оправдано, если поисковая строка вбивается оператором вручную и в ходе набивания возможны опечатки. Пример такого запроса (запрос находит запись с именем &laquo;Nice&raquo;):</span></p><ac:structured-macro ac:name="code"><ac:plain-text-body><![CDATA[            var queryTypefied = _client.Search<School>(s => s
                .Query(q => q
                    .FuzzyLikeThis(m => m
                        .OnFields( f => f.Name)
                        .LikeText("Niwe")
                    )
                )
            );

            var query = _client.Search(s => s
                .Query(q => q
                    .FuzzyLikeThis(m => m
                        .OnFields(new []{"name"})
                        .LikeText("Niwe")
                    )
                )
            );]]></ac:plain-text-body></ac:structured-macro><p><span>Представленные выражения для поиска по строке обладают различной производительностью. Для сравнения производительности был проведен тест, в рамках которого измерена скорость проведения 10000 запросов к индексу. Результаты теста:</span></p><table><tbody><tr><th>Способ поиска</th><th>Поисковый термин</th><th colspan="1">Время выполнения (ЧЧ:ММ:СС.ммм)</th></tr><tr><td>Wildcard</td><td>&quot;street1&quot; &nbsp;+ Random.Next(100) + &quot;*&quot;</td><td colspan="1">00:00:26.144</td></tr><tr><td colspan="1"><span>Wildcard</span></td><td colspan="1"><span>&quot;?treet&quot; &nbsp;+ Random.Next(100) + &quot;*&quot;</span></td><td colspan="1"><span>00:01:49.588</span></td></tr><tr><td>TextPhrasePrefix</td><td>&quot;street&quot; + Random.Next(999)</td><td colspan="1">00:00:25.690</td></tr><tr><td>FuzzyLikeThis</td><td>&quot;strewt&quot; + Random.Next(999)</td><td colspan="1">00:04:32.603</td></tr><tr><td colspan="1">Term&nbsp;</td><td colspan="1">&quot;street&quot; + Random.Next(999)</td><td colspan="1">00:00:05.497</td></tr></tbody></table><h3><span>Поиск данных по дате</span></h3><p>ElasticSearch позволяет выполнять запросы с соответствием по полю типа DateTime. Например, требуется найти все школы, которые были основаны определенного числа. Запрос будет выглядеть следующим образом:</p><ac:structured-macro ac:name="code"><ac:plain-text-body><![CDATA[            var queryTypefied = _client.Search<School>(s => s
                .Query(q => q
                    .Term(t => t.FoundationDate, new DateTime(1988, 10, 1))
                )
            );

            var query = _client.Search(s => s
                .Query(q => q
                    .Term("foundationDate", new DateTime(1988, 10, 1))
                )
            );]]></ac:plain-text-body></ac:structured-macro><p><span>Если требуется найти остальные школы (за исключением школы, основанной определенного числа), необходимо использовать символ ! перед соответствующим Term:</span></p><ac:structured-macro ac:name="code"><ac:plain-text-body><![CDATA[            var queryTypefied = _client.Search<School>(s => s
                .Query(q => !q
                    .Term(t => t.FoundationDate, new DateTime(1988, 10, 1))
                )
            );

            var query = _client.Search(s => s
                .Query(q => !q
                    .Term("foundationDate", new DateTime(1988, 10, 1))
                )
            );]]></ac:plain-text-body></ac:structured-macro><p><span>Запрос с проверкой на то, что значение в поле типа DateTime находится&nbsp; в определенном диапазоне, будет выглядеть следующим образом:</span></p><ac:structured-macro ac:name="code"><ac:plain-text-body><![CDATA[            var queryTypefied = _client.Search<School>(s => s
                .Filter(q => q
                    .Range(r => r.OnField(f => f.FoundationDate)
                        .From(new DateTime(1987, 10, 1))
                        .To(new DateTime(1989, 10, 1))
                    )
                )
            );

            var query = _client.Search(s => s
                .Filter(q => q
                    .Range(r => r.OnField("foundationDate")
                        .From(new DateTime(1987, 10, 1))
                        .To(new DateTime(1989, 10, 1))
                    )
                )
            );]]></ac:plain-text-body></ac:structured-macro><p><span>Допустимы запросы по различным критериям (больше, меньше, больше или равно, меньше или равно).</span></p><p>Запрос для получения школ, основанных после 1 октября 1988 года:</p><ac:structured-macro ac:name="code"><ac:plain-text-body><![CDATA[            var queryTypefied = _client.Search<School>(s => s
                .Filter(q => q
                    .Range(r => r.OnField(f => f.FoundationDate)
                        .Greater(new DateTime(1988, 10, 1))
                    )
                )
            );

            var query = _client.Search(s => s
                .Filter(q => q
                    .Range(r => r.OnField("foundationDate")
                        .Greater(new DateTime(1988, 10, 1))
                    )
                )
            );]]></ac:plain-text-body></ac:structured-macro><p>Запрос для получения школ, основанных до 1 октября 1988 года:</p><ac:structured-macro ac:name="code"><ac:plain-text-body><![CDATA[            var queryTypefied = _client.Search<School>(s => s
                .Filter(q => q
                    .Range(r => r.OnField(f => f.FoundationDate)
                        .Lower(new DateTime(1988, 10, 1))
                    )
                )
            );

            var query = _client.Search(s => s
                .Filter(q => q
                    .Range(r => r.OnField("foundationDate")
                        .Lower(new DateTime(1988, 10, 1))
                    )
                )
            );]]></ac:plain-text-body></ac:structured-macro><p>Запрос для получения школ, основанных с 1 октября 1988 года включительно:</p><ac:structured-macro ac:name="code"><ac:plain-text-body><![CDATA[            var queryTypefied = _client.Search<School>(s => s
                .Filter(q => q
                    .Range(r => r.OnField(f => f.FoundationDate)
                        .GreaterOrEquals(new DateTime(1988, 10, 1))
                    )
                )
            );
            var query = _client.Search(s => s
                .Filter(q => q
                    .Range(r => r.OnField("foundationDate")
                        .GreaterOrEquals(new DateTime(1988, 10, 1))
                    )
                )
            );]]></ac:plain-text-body></ac:structured-macro><p>Запрос для получения школ, основанных до 1 октября 1988 года включительно:</p><ac:structured-macro ac:name="code"><ac:plain-text-body><![CDATA[            var queryTypefied = _client.Search<School>(s => s
                .Filter(q => q
                    .Range(r => r.OnField(f => f.FoundationDate)
                        .LowerOrEquals(new DateTime(1988, 10, 1))
                    )
                )
            );
            var query = _client.Search(s => s
                .Filter(q => q
                    .Range(r => r.OnField("foundationDate")
                        .LowerOrEquals(new DateTime(1988, 10, 1))
                    )
                )
            );]]></ac:plain-text-body></ac:structured-macro><h3><span style="line-height: 1.4285715;">&nbsp;</span><span style="font-size: 16.0px;line-height: 1.5625;">Поиск данных по полю типа integer и double</span></h3><p><span style="line-height: 1.4285715;">Запросы по полям типа integer и double полностью аналогичны запросам, представленным ранее с полями типа DateTime.</span></p><p>Например, запрос для получения школ, с номером дома от 25 до 35:</p><ac:structured-macro ac:name="code"><ac:plain-text-body><![CDATA[            var queryTypefied = _client.Search<School>(s => s
                .Filter(q => q
                    .Range(r => r.OnField(f => f.HouseNumber)
                        .From(25)
                        .To(35)
                    )
                )
            );
            var query = _client.Search(s => s
                .Filter(q => q
                    .Range(r => r.OnField("houseNumber")
                        .From(25)
                        .To(35)
                    )
                )
            );]]></ac:plain-text-body></ac:structured-macro><p>Запрос для получения школ, с рейтингом до 3.1 включительно:</p><ac:structured-macro ac:name="code"><ac:plain-text-body><![CDATA[            var queryTypefied = _client.Search<School>(s => s
                .Filter(q => q
                    .Range(r => r.OnField(f => f.Rating)
                        .LowerOrEquals(3.1)
                    )
                )
            );
            var query = _client.Search(s => s
                .Filter(q => q
                    .Range(r => r.OnField("rating")
                        .LowerOrEquals(3.1)
                    )
                )
            );]]></ac:plain-text-body></ac:structured-macro><h3>Фильтрация данных по полям вложенных коллекций</h3><p>Рассмотрим несколько примеров, в рамках которых будем запрашивать школы, в которых учатся ученики с определенными свойствами.</p><p>Запрос для получения всех школ, в которых учатся ученики с определенным рейтингом:</p><ac:structured-macro ac:name="code"><ac:plain-text-body><![CDATA[            var query = _client.Search(s => s
                .Query(q => q
                    .Term("students.knowledgeRating", 4.0)   // оба варианта равнозначны
                    //.Term(f => f.Students.First().KnowledgeRating, 4.0)
                )
            );]]></ac:plain-text-body></ac:structured-macro><p>&nbsp;Аналогичным образом можно делать запросы с соответствием по полю типа string, integer, DateTime:</p><ac:structured-macro ac:name="code"><ac:plain-text-body><![CDATA[            var query = _client.Search(s => s
                .Filter(q => q
                    .Term("students.favoriteSubject", "English".ToLowerInvariant()) // оба варианта равнозначны
                    //.Term(f => f.Students.First().FavoriteSubject, "English".ToLowerInvariant())
                )
            );]]></ac:plain-text-body></ac:structured-macro><p>Помимо запросов со строгим соответствием, допустимо использовать неравенства или поиск по диапазону:</p><ac:structured-macro ac:name="code"><ac:plain-text-body><![CDATA[            var query = _client.Search(s => s
                .Filter(q => q
                    .Range(r => r.OnField("students.countOfFriends")
                        .Greater(10)
                    )
                )
            );]]></ac:plain-text-body></ac:structured-macro><p>Рассмотрим комплексный запрос, являющийся комбинацией нескольких запросов. Построение таких запросов производится с помощью ключевого слова bool. Например, необходимо найти школы, в которых учатся студенты определенного года рождения с определенными именами:</p><ac:structured-macro ac:name="code"><ac:plain-text-body><![CDATA[            query = _client.Search<School>(s => s
                .Fields(f => f.Students[0].BirthDate, f => f.Students[0].Name)
                .Filter(q => q
                    .Bool(b => b
                        .Must(
                            m => m.MatchAll()
                        )
                        .MustNot(
                            mn => mn.Term(f => f.Students[0].Name, "roman")
                        )
                        .Should(sh => sh
                            .Range(r => r.OnField(f => f.Students[0].BirthDate)
                                .From(new DateTime(1989, 1, 1))
                                .To(new DateTime(1991, 1, 1))
                            )
                        )
                    )
                )
            );]]></ac:plain-text-body></ac:structured-macro><p>Использование ключевых слов в запросе:</p><ul><li>Must - определяет условие, которому обязательно должен удовлетворять документ</li><li>Should - если в запросе нет ни одного выражения must, одно или несколько should-условий должны выполняться, чтобы документ удовлетворил запросу. Минимальное количество&nbsp;should-условий, после которых документ считается удовлетворившим запросу, может быть настроено.</li><li>MustNot&nbsp;&nbsp;- определяет условие, которому документ должен не удовлетворять</li></ul><p>Рассмотрим пример с сортировкой результатов запроса исходя из значений, вычисленных в соответствии со скриптом:</p><ac:structured-macro ac:name="code"><ac:plain-text-body><![CDATA[            var query = _client.Search<School>(s => s
                .From(0)
                .Size(10)
                .SortScript(sort => sort
                    .Ascending()
                    .Script("doc['principal.knowledgeRating'].value * factor")
                    .Params(p => p
                        .Add("factor", -1)
                    )
                    .Type("number")
                )
            );]]></ac:plain-text-body></ac:structured-macro><p>Из-за того, что фактор равен -1, школы будут отсортированы по убыванию рейтинга директора.</p><h3>Построение запросов с агрегацией результатов (Facets)</h3><p>ElasticSearch поддерживает несколько типов запросов с агрегацией результатов. Вот некоторые из них:</p><ul><li>Range Facet - позволяет сгруппировать результаты по набору диапазонов и рассчитать общее количество документов, попавших в каждый из диапазонов.</li><li>Histogram Facet - позволяет сгруппировать результаты, имеющие одинаковые (или близкие) значения определенных полей. В частности, Date Histogram Facet позволяет подсчитать количество документов по дням, месяцам и т.д.</li><li>Query/Filter Facet - позволяет получить количество документов, удовлетворяющих определенному условию.</li><li>Statistical Facet &nbsp;- позволяет вычислить статистические характеристики на основе числового поля. Статистические характеристики включают в себя сумму значений, среднее значение, минимальное значение и т.д.&nbsp;</li></ul><p>Рассмотрим несколько примеров.&nbsp;</p><p>Получение статистических данных по рейтингу для всех школ с&nbsp;одинаковым номером дома (номер дома должен быть также в определенном диапазоне)</p><ac:structured-macro ac:name="code"><ac:plain-text-body><![CDATA[            var query = _client.Search<School>(s => s
                .MatchAll()
                .FacetTermsStats(gf => gf
                    .KeyField("houseNumber")
                    .ValueField(f => f.Rating)
                    .FacetFilter(ff => ff
                        .Range(r => r.OnField("houseNumber")
                            .From(30)
                            .To(40)
                        )                        
                    )
                )
            );
            
            var statistic = query.Facets.First().Value as TermStatsFacet;
            Assert.AreEqual(3.1, statistic.Items.First().Mean);
            Assert.AreEqual(3.1, statistic.Items.First().Max);
            Assert.AreEqual(3.1, statistic.Items.First().Min);
            Assert.AreEqual(1, statistic.Items.First().Count);
            Assert.AreEqual(3.1, statistic.Items.First().Total);]]></ac:plain-text-body></ac:structured-macro><p>Более простой вариант, когда статистические характеристики вычисляются для всех документов без дополнительной фильтрации:</p><ac:structured-macro ac:name="code"><ac:plain-text-body><![CDATA[            var query = _client.Search<School>(s => s
                .Filter(q => q.MatchAll())
                .FacetStatistical(fs => fs.OnField(f => f.Rating)));
    ]]></ac:plain-text-body></ac:structured-macro><p>Получение количества школ, которые были основаны в определенном году с помощью Date Histogram Facet:</p><ac:structured-macro ac:name="code"><ac:plain-text-body><![CDATA[            var query = _client.Search<School>(s => s
                .Filter(q => q.MatchAll())
                .FacetDateHistogram(f => f
                    .OnField(ff => ff.FoundationDate)
                    .Interval(DateInterval.Year)
                )
            );]]></ac:plain-text-body></ac:structured-macro><p>Пример использования&nbsp;Range Facet совместно со скриптом:</p><ac:structured-macro ac:name="code"><ac:plain-text-body><![CDATA[            var query = _client.Search(s => s
                .MatchAll()
                .FacetRange<double>("any_name",
                f => f.KeyScript("doc['rating'].value")
                    .ValueScript("doc['houseNumber'].value * doc['rating'].value")
                    .Ranges(r => r.From(3)
                    )
                )
            );
            var facet = query.Facets.First().Value as RangeFacet;]]></ac:plain-text-body></ac:structured-macro><p>В данном случае д<span style="line-height: 1.4285715;">ля всех школ, у которых рейтинг больше 3</span><span style="line-height: 1.4285715;">&nbsp;рассчитается значение выражения houseNumber * rating и</span><span style="line-height: 1.4285715;">&nbsp;затем рассчитаются&nbsp;статистические показатели (средние значение, минимум, максимум) по вычисленным выражениями.</span></p><h5>Дополнительные материалы</h5><ol><li><a href="http://nest.azurewebsites.net/" style="line-height: 1.4285715;">Документация по использованию клиента NEST</a></li><li><a href="http://joelabrahamsson.com/extending-aspnet-mvc-music-store-with-elasticsearch/" style="line-height: 1.4285715;">Пример использования ElasticSearch для расширения функциональности приложения Music Sore</a><span style="line-height: 1.4285715;">&nbsp;</span></li><li><a href="https://github.com/Mpdreamz/NEST">Исходный код NEST</a></li><li><a href="http://www.elasticsearch.org/">Документация по ElasticSearch</a></li></ol><p>&nbsp;</p><p>&nbsp;</p>