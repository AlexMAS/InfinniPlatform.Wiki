---
layout: default
title: Script
position: 5
categories: 
tags: 
---

<p>Прикладной скрипт, выполняемый на стороне клиента.</p><p>&nbsp;</p><ac:structured-macro ac:name="note"><ac:parameter ac:name="title">Важно</ac:parameter><ac:rich-text-body><p>Прикладной скрипт, выполняемый на стороне клиента, представляет собой функцию с двумя параметрами. В первом параметре (context) передается контекст (см. <ac:link><ri:page ri:content-title="Context" /></ac:link>), во втором параметре (arguments) передаются аргументы (см. <ac:link><ri:page ri:content-title="Arguments" /></ac:link>). Контекст предоставляет доступ к элементам представления (см. <ac:link><ri:page ri:content-title="View" /></ac:link>), с которым связан соответствующий скрипт. Например, через контекст можно получить доступ к любому визуальному элементу представления. Аргументы служат для передачи дополнительной информации, необходимой для выполнения скрипта. Например, обработчик события выделения элемента в списке в аргументах будет ожидать информацию о выделенном элементе.</p><p>Поскольку контекст (см. <ac:link><ri:page ri:content-title="Context" /></ac:link>) связан с представлением, время его жизни определяется временем жизни соответствующего представления. Последнее значит, что контекст можно использовать не только для доступа к элементам представления, но и в качестве своеобразного глобального объекта для хранения внутреннего состояния представления. С другой стороны, аргументы<span> (см. </span><ac:link><ri:page ri:content-title="Arguments" /></ac:link><span>)</span>, передаваемые в прикладной скрипт, создаются каждый раз при вызове скрипта, на время выполнения этого скрипта.</p><p>И контекст и аргументы являются динамическими объектами, однако это не значит, что нет никаких правил по работе с этими объектами. Напротив, API контекста жестко определен (см. <ac:link><ri:page ri:content-title="Context" /></ac:link>), API аргументов также жестко определен, но зависит от контекста вызова (для обработчика одного события аргументы будут содержать одну информацию, для обработчика другого события - другую). Если прикладной скрипт является пользовательской функцией, а не обработчиком какого-либо события, то разработчик скрипта сам определяет то, что будет предаваться в аргументах. Понятно, что динамическая природа контекста и аргументов может привести к тому, что API существенно усложнится из-за многообразия различных методов и свойств, а прикладные скрипты из-за этого станут трудно читаемыми и более сложными в поддержке (ведь прикладному разработчику нужно будет знать все многообразие методов и свойств этого API). Учитывая этот факт, при разработке API был сделан акцент на его лаконичность и единообразие, как в поведении, так и в названии методов и свойств.</p><p>На уровне метаданных, для описания прикладного скрипта указывается его наименование (Name) и тело функции (Body). Наименование прикладного скрипта в рамках представления, естественно, должно быть уникальным. Представление хранит список всех скриптов (см. Scripts, <ac:link><ri:page ri:content-title="View" /></ac:link>), которые могут быть вызваны в рамках данного представления, а обработчики событий элементов представления хранят только ссылку (см. <ac:link><ri:page ri:content-title="LinkScript" /></ac:link>) на объявленные ранее прикладные скрипты.</p><p><span>Чтобы обеспечить изолированную работу каждого представления (см. <ac:link><ri:page ri:content-title="View" /></ac:link>) в отдельности, на уровне реализации нужно обеспечить, чтобы <span>область видимости скрипта была ограничена только тем представлением, с которым связан данный скрипт. Иначе говоря, область видимости скрипта ограничивается его контекстом (см. <ac:link><ri:page ri:content-title="Context" /></ac:link>), изменение которого в общем случае никак не должно влиять на другие представления приложения.</span></span></p><p><span>В качестве примера рассмотрим </span><span>два представления: View1 и View2. Предположим, что у View1 есть скрипты: Script11, Script12; а у View2 скрипты: Script21, Script22. Также предположим, что у View1 есть кнопка Button1, а у View2 есть кнопка Button2. Так вот, в качестве обработчика события Button1.OnClick мы можем выбрать только Script11 или Script12, а в качестве обработчика Button2.OnClick мы можем выбрать только &nbsp;Script21 или Script22.</span></p></ac:rich-text-body></ac:structured-macro><p>&nbsp;&nbsp;</p><ac:structured-macro ac:name="code"><ac:parameter ac:name="title">JSON Data Schema</ac:parameter><ac:parameter ac:name="language">javascript</ac:parameter><ac:plain-text-body><![CDATA[{
	"id": "Script",
	"description": "Прикладной скрипт, выполняемый на стороне клиента",
	"type": "object",
	"properties": {
		"Name": {
			"description": "Наименование функции",
			"type": "string",
			"required": true
		},
		"Body": {
			"description": "Тело функции",
			"type": "string"
		}
	}
}]]></ac:plain-text-body></ac:structured-macro><p>&nbsp;</p><p>&nbsp;</p>