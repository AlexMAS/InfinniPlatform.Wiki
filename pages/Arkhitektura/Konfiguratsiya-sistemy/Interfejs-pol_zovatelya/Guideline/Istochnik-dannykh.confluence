---
layout: default
title: Источник данных
position: 3
categories: 
tags: 
---

<p>Базовая функциональность, которая связана с обменом данными между элементами представления, реализуется с использованием асинхронной шины сообщений (см. раздел&nbsp;<ac:link><ri:page ri:content-title="MessageBus" /></ac:link>). Эти же требования касаются задачи организации взаимодействия с источником данных представления (см. раздел&nbsp;<ac:link><ri:page ri:content-title="DataSource" /></ac:link>). Общая схема взаимодействия между элементами и источником данных через шину сообщений приведена на иллюстрации, полный перечень типов сообщений описан в разделе&nbsp;<ac:link><ri:page ri:content-title="MessageType" /></ac:link>. На иллюстрации приведен пример некоторого представления, который в общем напоминает журнал документов. В рамках этого представления определены несколько визуальных элементов: панель фильтров (<ac:link><ri:page ri:content-title="FilterPanel" /></ac:link>), панель полнотекстового поиска (<ac:link><ri:page ri:content-title="SearchPanel" /></ac:link>), таблица данных (<ac:link><ri:page ri:content-title="DataGrid" /></ac:link>), панель навигации по данным (<ac:link><ri:page ri:content-title="DataNavigation" /></ac:link>) и, например, кнопка, связанная с действием удаления выделенной записи из источника данных (<ac:link><ri:page ri:content-title="DeleteAction" /></ac:link>); а также не визуальный элемент - источник данных (<ac:link><ri:page ri:content-title="DataSource" /></ac:link>). Стрелками показаны потоки данных от элементов к шине и наоборот, а комментарии к стрелкам поясняют, какие сообщения элемент публикует в шину и на какие сообщения шины он подписан. Например, при изменении на панели фильтров, она публикует сообщение-запрос &quot;OnSetPropertyFilters&quot; на фильтрацию данных; источник данных, получив подобное сообщение, осуществляет фильтрацию данных, по результатам которой публикует сообщение-ответ &quot;OnPropertyFiltersChanged&quot;.</p><p>Почему элементы не могут напрямую обратиться к API источника данных и вызывать необходимые методы? По очень многим причинам. Во-первых, представление может иметь достаточно большое количество визуальных и не визуальных элементов, функционально связанных между собой (под функциональной связью в данном контексте в первую очередь понимается некоторая логика обмена данными между элементами). Более того, со временем количество элементов представления может измениться, количество функциональных связей может измениться,&nbsp;могут появиться новые типы элементов или измениться характер функциональных связей. Если при таких исходных данных функциональную связь между элементами делать императивно, то достаточно быстро произойдет комбинаторный взрыв, и развивать платформу будет невозможно. Во-вторых, прямое обращение к источнику будет осуществляться синхронно (в том же потоке), что приведет к зависанию интерфейса на время выполнения операции, а это крайне недопустимо и нужно, чтобы все операции с источником данных осуществлялись асинхронно (в отдельном потоке). В-третьих, в некоторых событиях может быть заинтересован не только один элемент, а сразу несколько, а реализация такой логики в рамках построителя элемента существенно усложнит его код. Это, пожалуй, основные, но далеко не все причины обоснования данной схемы взаимодействия.</p><p>&nbsp;</p><p><ac:image><ri:attachment ri:filename="DataSourceAndMessageBusAspects.png" /></ac:image></p><p>&nbsp;</p><p>&nbsp;</p>