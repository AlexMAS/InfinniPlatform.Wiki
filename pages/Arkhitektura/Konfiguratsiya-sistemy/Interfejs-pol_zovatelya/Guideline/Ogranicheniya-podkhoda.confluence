---
layout: default
title: Ограничения подхода
position: 6
categories: 
tags: 
---

<ac:structured-macro ac:name="warning"><ac:rich-text-body><p>Перечисленный ниже список требований можно считать границами области, в пределах которой может быть использован предложенный подход к описанию визуального представления формы. Соответственно, если прикладная задача не вписывается в указанные рамки, скорее всего, данная система описания не подходит для решения такой задачи.</p></ac:rich-text-body></ac:structured-macro><p>&nbsp; &nbsp;</p><p>Метаданные представления должны удовлетворять следующим важным критериям:</p><ul><li>Модель метаданных представления должна быть гибкой и расширяемой.</li><li>Визуальные и невизуальные элементы представления должны быть независимыми.</li><li>Уровень абстракции метаданных должен быть настолько высоким, насколько возможно.</li></ul><p>Иначе говоря, каждый элемент метаданных должен обладать слабой связностью по отношению к другим элементам, так как только за счет этого можно обеспечить возможность расширять модель метаданных, дополняя ее новыми элементами и механизмами. Дальше можно рассмотреть более низкоуровневые требования, которые можно разбить по категориям, каждая из которых отражает отдельный механизм или раздел метаданных представления.</p><h4>Визуальная часть</h4><ul><li>Представление и визуальные элементы должны обладать общим поведением и предоставлять общий API.</li><li>Должна существовать поддержка создания собственных повторно используемых визуальных компонентов.</li><li>Должны предоставляться различные настраиваемые раскладки интерфейса (сетка, стек, панель закладок и т.п.).</li><li>Должна предоставляться возможность встраивания сторонних визуальных компонентов (без изменения системного кода).</li><li>Должна существовать возможность написания прикладных скриптов, выполняемых на стороне клиента.</li><li>Должна существовать возможность визуальной шаблонизации данных (data template).</li></ul><h4>Работа с данными</h4><ul><li>Должна обеспечиваться единообразная работа с любым источником данных.</li><li>Должна существовать возможность разрабатывать новые типы источников данных.</li><li>Должен обеспечиваться единообразный механизм привязки к данным (data binding).</li><li>Должен обеспечиваться механизм передачи данных между различными представлениями.</li></ul><h4>Стандартное поведение</h4><ul><li>Должна существовать возможность декларативного задания типовых операций (открытие представления, CRUD-операции и т.п.).</li><li>Элементы должны предоставлять единообразный API (схожая сигнатура методов и свойств, предоставляющий схожий функционал).</li></ul><h4>Кроссплатформенность</h4><ul><li>Метаданные представления должны быть платформенно-нейтральными.</li></ul><p>&nbsp;</p><p>Помимо вышеприведенных требований нужно учитывать тот факт, что мы решаем достаточно узкоспециализированную задачу, которую можно охарактеризовать, как &quot;разработка решения для документо-ориентированных&nbsp;Enterprise-систем&quot;, имеющих в большинстве случаев однообразный (шаблонный/типовой/повторяющийся) интерфейс. В связи с этим для нас очень важно требование по обеспечению достаточно высокого уровня абстракции в части метаданных (насколько это возможно). Допустимость повышения или понижения абстракции определяется вышеприведенным списком требований. Да, более низкоуровневые абстракции предоставляют намного больше гибкости, но одновременно существенно усложняют процесс конфигурирования: создание (&quot;верстка&quot;) типового представления для системы может занять достаточно много времени, провоцирует дублирование кода и метаданных, что в свою очередь приводит к появлению ошибок, непредсказуемому и/или нестандартному поведению, отсутствию единого стиля оформления.</p><p>В связи с вышесказанным, вполне очевидно, что такие метаязыки, как XAML или GladeXML, вряд ли подходят и есть вполне существенная потребность в более высоком уровне абстракции. С другой стороны, на уровне реализации никто не запрещает интерпретировать более высокий уровень абстракции в низкоуровневые концепции (те же&nbsp;XAML или GladeXML). Более того, именно это и рекомендуется делать при реализации интерпретатора метаданных, чтобы не изобретать собственный &quot;велосипед&quot;, наступая на те же самые &quot;грабли&quot;, через которые прошли вышеуказанные решения.</p>