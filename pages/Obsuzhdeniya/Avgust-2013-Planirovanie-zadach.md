---
layout: default
title: Август 2013: Планирование задач
position: 
categories: 
tags: 
---

## Дата

05 August 2013

## Участники

 

* [[Межов, Александр|]]


* [[Солодков, Евгений|]]



 

## Цели

* Выполнить рефакторинг структуры проекта
* Доработка модели индексирования (ElasticSearch)
* Доработка модели потока выполнения бизнес-логики  * Машина состояний (state-machine)
  * Пересмотр концепции взаимодействия модулей бизнес-логики
  * Обеспечение работы с контекстом на уровне модулей бизнес-логики
  * Разработка механизма глобального/контекстного кэширования на этапе выполнения бизнес-модулей
  * Обеспечение поддержки скриптовых модулей бизнес-логики (Iron Python)    * Перенос бизнес-логики модулей ИЭМК с C# на скриптовый язык
    * Перенос бизнес-логики справочника РЛС с C# на скриптовый язык


  * Реализация асинхронной стратегии    * Формирование агрегатов на лету (если он еще не создан)      * Решить вопрос с Flush() после записи в индекс




  * Доработка механизма валидации данных
  * Реализация поддержки композитных (именованных) событий    * Согласованное сохранение ссылок на строки справочников


  * Проработка общей структуры метаданных конфигурации    * Хранилище метаданных конфигурации
    * Сервис сохранения и выборки метаданных  
      * Получение метаданных любого уровня вложенности


    * Метаданные источника данных      * Типы источников данных (by ID, paging, custom)






* Реализация горизонтального масштабирования  * Решение вопросов масштабирования для ElasticSearch
  * Решение вопросов масштабирования для Cassandra
  * Решение вопросов масштабирования для бизнес-модулей    * Рассмотрение вопросов применения шины сообщений (Rabbit Mq)




* Рефакторинг модели REST-сервисов (еще более композитная модель)
* Унификация механизма администрирования системы (в разрезе метаданных)
* Разработка утилиты для установки и настройки системы  * Инициализация системы
  * Пошаговая утилита с возможностью выбора устанавливаемых модулей


* Автодокументирование (сервисов, модулей и т.п.)
* Язык запросов

## Вопросы для обсуждения

|Вопрос|Комментарии|
|------|-----------|
|Доработка модели индексирования (ElasticSearch)|* Работа с динамическими объектами - удаление строгой типизации
* Состав полей контейнера индексируемого агрегата - фиксированный (для унификации и простоты)
* Разобраться с CamelCaseSerializer 
* Добавить возможность сортировки результатов поиска

|
|Машина состояний (state-machine)|* Что делать, если модель без состояний? (пока придерживаемся единой модели, проблему решаем на уровне API)
* Контекст каждого модуля строится по жестко определенному соглашению (convention)
* Набор обработчиков (Query Handler) задан жестко

|
|Унификация механизма администрирования системы (в разрезе метаданных)|* Регистрация провайдеров данных на уровне конфигурации подсистемы администрирования
* Каждый из уровней подсистемы администрирования умеет интерпретировать выходные данные провайдеров

|
|Разработка механизма глобального/контекстного кэширования на этапе выполнения бизнес-модулей|* Выделяем два кэша: global и workflow
* Делаем скриптовые точки расширения: initWorkflow и finalizeWorkflow
* В initWorkflow регистрируем ключи и Func<object> для ключей workflow-кэша
* На уровне бизнес-модулей контекст имеет ссылку только на workflow-кэш
* Данные из workflow-кэша запрашиваются по ключу
* Если данных в workflow-кэше нет, он их пытается найти в global
* Если данных нет в global-кэше, он возвращает null

|
|Реализация асинхронной стратегии|* Вводим понятие Edit Query Handler, который принимает ID агрегата
* Если агрегат не найден в индексе, он формируется из событий
* Сформированный агрегат не сохраняется в индексе 
* Необходимо как-то сигнализировать о таких ситуациях (когда агрегата нет в индексе)
* Есть процедура восстановления, которая следит за тем, что в индексе есть актуальные агрегаты

|
|Проработка общей структуры метаданных конфигурации|* Серверная конфигурация:  * Метаданные источника данных содержат информацию о полях данных и список доступных действий над этими данными (Actions)
  * Помимо этого есть Workflow Actions
  * Проверка безопасности осуществляется отдельным сервисом в runtime


* Конфигурация представления:  * Содержит содержит именованные настройки доступных действий выбранного источника данных. Это есть "источник данных" в понятиях дизайнера форм
  * Grid ссылается на вышеуказанный "источник данных" и содержит настройки полей выбранного источника данных (видимое поле или нет, ссылочное или нет, глубина выборки (если поле ссылочное), data template и т.д.)



|
|Рефакторинг модели REST-сервисов (еще более композитная модель)|* Отказ от StandardApi и т.п. в роутенге и замена этого механизма на ControllerSelector, который  * Будет брать конфигурацию сервисов
  * Через IoC создавать враппер, способный обработать запрос
  * Вызывать враппер, который будет вызывать бизнес-обработчик запроса


* В конфигурации сервисов  * Можно добавить сервис, указав его имя: Add(string name, Action<ServiceMethodBuilder> methods)
  * Сервису можно добавить список методов типа: Get, Post, Put, Delete
  * У каждого из методов можно указать бизнес-обработчик запроса (отвязанный от специфики Web-а) и указать способ интерпретации параметров (например, Streamed или NonStreamed) и обработки результатов работы бизнес-обработчика (в том числе исключений)
  * У сервиса можно указать способ интерпретации результатов работы бизнес-обработчиков по умолчанию


* Произвести рефакторинг FileController-а в вышеуказанном разрезе

|
|Реализация горизонтального масштабирования|* Нужен API для администрирования кластера
* Нужен UI для администрирования кластера

|
|Автодокументирование (сервисов, модулей и т.п.)|* В конфигурацию сервисов можно добавить Get<HelpRequestHandler>("Help"), который читает XML-документацию RequestHandler-ов данного сервиса и возвращает Html-страницу с их описанием.

|
|Язык запросов|* Разделяем легковесную выборку данных по хранилищу медицинских документов (индексному хранилищу) и тяжеловесную (статистическую) выборку данных
* Легковесную выборку данных по хранилищу медицинских документов (индексному хранилищу) реализуем в виде REST API  * Поисковой запрос оформляется в виде дерева выражения, представленного в JSON-формате
  * Для ссылочных полей указывается глубина выборки и наименование связанного индекса
  * Ссылочные поля выбираются из индексов по идентификатору
  * Легковесная выборка предназначена: для построения UI (в частности гридов) и для формирования простых печатных форм


* Тяжеловесную (статистическую) выборку данных реализуем на базе какого-нибудь OLAP-движка  * В системе реализуем механизм Exporter-ов, которые могут работать в режимах    * экспорт по требованию
    * экспорт по расписанию
    * экспорт по подписке на событие (Rabbit)


  * Сервис экспорта работает на какой-нибудь машине (слабенькой) и хостит Exporter-ы
  * Каждый из Exporter-ов выполняет свою узкоспециализированную задачу
  * Определенные Exporter-ы могут формировать регистровую базу для OLAP



|
| | |

