---
layout: default
title: Август 2013: Планирование задач
position: 
categories: 
tags: 
---

<h2>Дата</h2><p>05 August 2013</p><h2>Участники</h2><p>&nbsp;</p><ul><li><p><ac:link><ri:user ri:userkey="8a5e5e9644cbd0fe0144cbd16aa10021" /><ac:plain-text-link-body><![CDATA[Межов, Александр]]></ac:plain-text-link-body></ac:link></p></li><li><p><ac:link><ri:user ri:userkey="8a5e5e9644cbd0fe0144cbd16acd0058" /><ac:plain-text-link-body><![CDATA[Солодков, Евгений]]></ac:plain-text-link-body></ac:link></p></li></ul><p>&nbsp;</p><h2>Цели</h2><ul><li>Выполнить рефакторинг структуры проекта</li><li>Доработка модели индексирования (ElasticSearch)</li><li>Доработка модели потока выполнения бизнес-логики<ul><li>Машина состояний (state-machine)</li><li>Пересмотр концепции взаимодействия модулей бизнес-логики</li><li>Обеспечение работы с контекстом на уровне модулей бизнес-логики</li><li>Разработка механизма глобального/контекстного кэширования на этапе выполнения бизнес-модулей</li><li>Обеспечение поддержки скриптовых модулей бизнес-логики (Iron Python)<ul><li>Перенос бизнес-логики модулей ИЭМК с C# на скриптовый язык</li><li>Перенос бизнес-логики справочника РЛС с C# на скриптовый язык</li></ul></li><li>Реализация асинхронной стратегии<ul><li>Формирование агрегатов на лету (если он еще не создан)<ul><li>Решить вопрос с Flush() после записи в индекс</li></ul></li></ul></li><li>Доработка механизма валидации данных</li><li>Реализация поддержки композитных (именованных) событий<ul><li>Согласованное сохранение ссылок на строки справочников</li></ul></li><li>Проработка общей структуры метаданных конфигурации<ul><li>Хранилище метаданных конфигурации</li><li><span style="line-height: 1.4285715;">Сервис сохранения и выборки метаданных</span><br /><ul><li>Получение метаданных любого уровня вложенности</li></ul></li><li>Метаданные источника данных<ul><li>Типы источников данных (by ID, paging, custom)</li></ul></li></ul></li></ul></li><li>Реализация горизонтального масштабирования<ul><li>Решение вопросов масштабирования для ElasticSearch</li><li>Решение вопросов масштабирования для Cassandra</li><li>Решение вопросов масштабирования для бизнес-модулей<ul><li>Рассмотрение вопросов применения шины сообщений (Rabbit Mq)</li></ul></li></ul></li><li>Рефакторинг модели REST-сервисов (еще более композитная модель)</li><li>Унификация механизма администрирования системы (в разрезе метаданных)</li><li>Разработка утилиты для установки и настройки системы<ul><li>Инициализация системы</li><li>Пошаговая утилита с возможностью выбора устанавливаемых модулей</li></ul></li><li>Автодокументирование (сервисов, модулей и т.п.)</li><li>Язык запросов</li></ul><h2>Вопросы для обсуждения</h2><table><tbody><tr><th>Вопрос</th><th>Комментарии</th></tr><tr><td>Доработка модели индексирования (ElasticSearch)</td><td><ul><li>Работа с динамическими объектами - удаление строгой типизации</li><li>Состав полей контейнера индексируемого агрегата - фиксированный (для унификации и простоты)</li><li>Разобраться с CamelCaseSerializer<span style="line-height: 1.4285715;">&nbsp;</span></li><li><span style="line-height: 1.4285715;">Добавить возможность сортировки результатов поиска</span></li></ul></td></tr><tr><td><p>Машина состояний (state-machine)</p></td><td><ul><li><span style="line-height: 1.4285715;">Что делать, если модель без состояний? (пока придерживаемся единой модели, проблему решаем на уровне API)</span></li><li><span style="line-height: 1.4285715;">Контекст каждого модуля строится по жестко определенному соглашению (convention)</span></li><li>Набор обработчиков (Query Handler) задан жестко</li></ul></td></tr><tr><td colspan="1"><p>Унификация механизма администрирования системы (в разрезе метаданных)</p></td><td colspan="1"><ul><li>Регистрация провайдеров данных на уровне конфигурации подсистемы администрирования</li><li>Каждый из уровней подсистемы администрирования умеет интерпретировать выходные данные провайдеров</li></ul></td></tr><tr><td colspan="1"><p>Разработка механизма глобального/контекстного кэширования на этапе выполнения бизнес-модулей</p></td><td colspan="1"><ul><li>Выделяем два кэша: global и workflow</li><li>Делаем скриптовые точки расширения: initWorkflow и finalizeWorkflow</li><li>В initWorkflow регистрируем ключи и Func&lt;object&gt; для ключей <span>workflow-</span>кэша</li><li>На уровне бизнес-модулей контекст имеет ссылку только на workflow-кэш</li><li><span>Данные из workflow-кэша запрашиваются по ключу</span></li><li><span>Если данных в <span>workflow-</span>кэше нет, он их пытается найти в global</span></li><li><span>Если данных нет в global-кэше, он возвращает null</span></li></ul></td></tr><tr><td colspan="1">Реализация асинхронной стратегии</td><td colspan="1"><ul><li>Вводим понятие Edit Query Handler, который принимает ID агрегата</li><li>Если агрегат не найден в индексе, он формируется из событий</li><li>Сформированный агрегат не сохраняется в индексе <ac:emoticon ac:name="warning" /></li><li>Необходимо как-то сигнализировать о таких ситуациях (когда агрегата нет в индексе)</li><li>Есть процедура восстановления, которая следит за тем, что в индексе есть актуальные агрегаты</li></ul></td></tr><tr><td colspan="1">Проработка общей структуры метаданных конфигурации</td><td colspan="1"><ul><li>Серверная конфигурация:<ul><li>Метаданные источника данных содержат информацию о полях данных и список доступных действий над этими данными (Actions)</li><li>Помимо этого есть Workflow Actions</li><li>Проверка безопасности осуществляется отдельным сервисом в runtime</li></ul></li><li>Конфигурация представления:<ul><li>Содержит содержит именованные настройки доступных действий выбранного источника данных. Это есть &quot;источник данных&quot; в понятиях дизайнера форм</li><li>Grid ссылается на вышеуказанный &quot;источник данных&quot; и содержит настройки полей выбранного источника данных (видимое поле или нет, ссылочное или нет, глубина выборки (если поле ссылочное), data template и т.д.)</li></ul></li></ul></td></tr><tr><td colspan="1"><p>Рефакторинг модели REST-сервисов (еще более композитная модель)</p></td><td colspan="1"><ul><li>Отказ от StandardApi и т.п. в роутенге и замена этого механизма на ControllerSelector, который<ul><li>Будет брать конфигурацию сервисов</li><li>Через IoC создавать враппер, способный обработать запрос</li><li>Вызывать враппер, который будет вызывать бизнес-обработчик запроса</li></ul></li><li>В конфигурации сервисов<ul><li>Можно добавить сервис, указав его имя: Add(string name, Action&lt;ServiceMethodBuilder&gt; methods)</li><li>Сервису можно добавить список методов типа: Get, Post, Put, Delete</li><li>У каждого из методов можно указать бизнес-обработчик запроса (отвязанный от специфики Web-а) и указать способ интерпретации параметров (например, Streamed или NonStreamed) и обработки результатов работы бизнес-обработчика (в том числе исключений)</li><li>У сервиса можно указать способ интерпретации результатов работы бизнес-обработчиков <span>по умолчанию</span></li></ul></li><li><span>Произвести рефакторинг FileController-а в вышеуказанном разрезе</span></li></ul></td></tr><tr><td colspan="1">Реализация горизонтального масштабирования</td><td colspan="1"><ul><li>Нужен API для администрирования кластера</li><li>Нужен UI для администрирования кластера</li></ul></td></tr><tr><td colspan="1"><p>Автодокументирование (сервисов, модулей и т.п.)</p></td><td colspan="1"><ul><li>В конфигурацию сервисов можно добавить Get&lt;HelpRequestHandler&gt;(&quot;Help&quot;), который читает XML-документацию <span>RequestHandler-ов данного сервиса и</span> возвращает Html-страницу с их описанием.</li></ul></td></tr><tr><td colspan="1"><p>Язык запросов</p></td><td colspan="1"><ul><li>Разделяем легковесную выборку данных по хранилищу медицинских документов (индексному хранилищу) и тяжеловесную (статистическую) выборку данных</li><li>Легковесную выборку данных по <span>хранилищу медицинских документов (индексному хранилищу) реализуем в виде REST API</span><ul><li>Поисковой запрос оформляется в виде дерева выражения, представленного в JSON-формате</li><li>Для ссылочных полей указывается глубина выборки и наименование связанного индекса</li><li>Ссылочные поля выбираются из индексов по идентификатору</li><li><u>Легковесная выборка предназначена</u>: для построения UI (в частности гридов) и для формирования простых печатных форм</li></ul></li><li>Тяжеловесную (статистическую) выборку данных реализуем на базе какого-нибудь OLAP-движка<ul><li>В системе реализуем механизм Exporter-ов, которые могут работать в режимах<ul><li>экспорт по требованию</li><li>экспорт по расписанию</li><li>экспорт по подписке на событие (Rabbit)</li></ul></li><li>Сервис экспорта работает на какой-нибудь машине (слабенькой) и хостит <span>Exporter-ы</span></li><li><span>Каждый из <span>Exporter-ов выполняет свою узкоспециализированную задачу</span></span></li><li><span><span>Определенные <span>Exporter-ы могут формировать регистровую базу для OLAP</span></span></span></li></ul></li></ul></td></tr><tr><td colspan="1">&nbsp;</td><td colspan="1">&nbsp;</td></tr></tbody></table>