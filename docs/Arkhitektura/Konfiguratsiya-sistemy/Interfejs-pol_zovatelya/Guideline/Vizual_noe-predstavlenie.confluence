---
layout: default
title: "Визуальное представление"
position: 0
categories: 
tags: 
---

<p>Ключевым понятием при описании интерфейса пользователя является визуальное представление (см. раздел&nbsp;<ac:link><ri:page ri:content-title="View" /></ac:link>). Представление имеет достаточно много аспектов, каждый из которых более подробно будет описан ниже. Пока следует сказать, что каждый из этих аспектов отвечает за достаточно узкий круг задач и никак не зависит от других аспектов представления. Все необходимые связи между аспектами устанавливаются инфраструктурой приложения в момент выполнения (если быть точным, то в момент интерпретации метаданных представления). Подобная независимость и модульность позволяет достаточно свободно расширять модель представления и достаточно просто вносить изменения в каждый из ее аспектов.</p><p>Также следует отметить, что представление и все, что с ним связано, не завязано на какую-то конкретную предметную область.&nbsp;Напротив, для обеспечения большей гибкости и расширения границ применения, все аспекты представления, с одной стороны, никак не связаны с конкретной предметной областью, с другой &ndash; образуют достаточно полный функциональный базис, используя который можно решить подавляющую часть задач, возникающих на уровне интерфейса пользователя. Естественно, что за подобную универсальность приходится платить и в данном случае это отражается на несколько низкоуровневом характере аспектов представления, но не настолько низкоуровневом, чтобы эти аспекты не были бы понятны прикладному разработчику. Более того, предполагается, что многие задачи будут решаться с использованием автогенерированных представлений, а с учетом наличия механизма, который позволяет прикладным разработчикам разрабатывать генераторы представлений (см. раздел <ac:link><ri:page ri:content-title="Generator" /></ac:link>), подобная расплата за гибкость не кажется такой высокой.</p><p>Основные аспекты представления приведены в списке ниже и на иллюстрации.</p><ul><li><ac:link ac:anchor="Scripts"><ac:plain-text-link-body><![CDATA[Прикладные скрипты (Scripts)]]></ac:plain-text-link-body></ac:link></li><li><ac:link ac:anchor="Context"><ac:plain-text-link-body><![CDATA[Контекст представления (Context)]]></ac:plain-text-link-body></ac:link><span style="line-height: 1.4285715;">&nbsp;</span><span style="line-height: 1.4285715;">&nbsp;</span></li><li><ac:link ac:anchor="MessageBus"><ac:plain-text-link-body><![CDATA[Шина сообщений (Message Bus)]]></ac:plain-text-link-body></ac:link></li><li><ac:link ac:anchor="DataSources"><ac:plain-text-link-body><![CDATA[Источники данных (Data Sources)]]></ac:plain-text-link-body></ac:link></li><li><ac:link ac:anchor="LayoutPanel"><ac:plain-text-link-body><![CDATA[Контейнер элементов (Layout Panel)]]></ac:plain-text-link-body></ac:link></li></ul><p>&nbsp;</p><p><ac:image><ri:attachment ri:filename="ViewAspects.png" /></ac:image></p><p>&nbsp;</p><h4>Прикладные скрипты<ac:structured-macro ac:name="anchor"><ac:parameter ac:name="">Scripts</ac:parameter></ac:structured-macro></h4><p>Прикладные скрипты&nbsp;(см. раздел&nbsp;<ac:link><ri:page ri:content-title="Script" /></ac:link>) предназначены для написания прикладных обработчиков, выполняемых на стороне клиента, которые будут срабатывать при возникновении определенных событий в рамках представления. Чаще всего прикладные скрипты представляют собой обработчики событий элементов представления, но могут выступать и в качестве повторно используемых функций, которые могут быть вызваны из любого другого скрипта представления. Прикладные скрипты задают императивную логику обработки некоторого события, используя API, предоставленный платформой. На данный момент эта логика задается на платформенно-специфичном языке программирования: JavaScript (для Web-приложений), Java (для Android-приложений), C# (для Windows-приложений). Возможно, в будущем для написания прикладных скриптов будет использоваться один язык для всех платформ (например, JavaScript), но есть основания предполагать, что в этом, скорей всего, не будет никакого смысла, поскольку каждая платформа слишком индивидуальна и конфигурация для каждой из них будет, скорей всего, своя.</p><p>Для обеспечения стабильности работы основной акцент делается на то, чтобы у приложения не было никакого глобального контекста (состояния), который мог бы повлиять на корректность работы приложения. Именно по этой причине&nbsp;все прикладные скрипты регистрируются в рамках представления, а область их видимости ограничена представлением и его элементами. Иными словами, у представления, конечно, есть контекст, но область видимости этого контекста ограничивается представлением, соответственно, у прикладного скрипта в общем случае отсутствует какая-либо возможность повлиять на что-то, что выходит за рамки представления, к которому относится этот скрипт.</p><h4><span style="line-height: 1.5;">Контекст представления</span><ac:structured-macro ac:name="anchor"><ac:parameter ac:name="">Context</ac:parameter></ac:structured-macro></h4><p>Контекст представления&nbsp;(см. раздел&nbsp;<ac:link><ri:page ri:content-title="Context" /></ac:link>) - это программный объект, который хранит состояние представления и предоставляет строго определенный API для доступа к элементам представления. Вызов любого прикладного скрипта или обработчика события сопровождается передачей ему контекста представления, благодаря чему контекст является одним из ключевых аспектов, когда речь заходит о написании прикладных скриптов.&nbsp;Контекст создается для каждого экземпляра представления и время его жизни определяется временем жизни соответствующего экземпляра представления. Иными словами, каждое представление имеет свой контекст, который связан только с данным представлением. Мотивы в подобной изоляции всё те же - для обеспечения стабильности работы приложения. Также следует отметить, что контекст является динамическим объектом и&nbsp;<span>не исключено, что с течением времени, вследствие выполнения прикладных скриптов, контекст может динамически расширяться дополнительными свойствами и методами.</span></p><h4>Шина сообщений<ac:structured-macro ac:name="anchor"><ac:parameter ac:name="">MessageBus</ac:parameter></ac:structured-macro></h4><p>Представление может иметь достаточно большое количество визуальных и не визуальных элементов, функционально связанных между собой. Более того, со временем количество элементов представления может измениться, количество функциональных связей может измениться,&nbsp;могут появиться новые типы элементов или измениться характер функциональных связей. Если при таких исходных данных функциональную связь между элементами делать императивно, то достаточно быстро произойдет комбинаторный взрыв, и развивать платформу будет невозможно. Однако, несмотря на непредсказуемость и сложность функциональных связей, типы связей достаточно предсказуемы и вполне определены. Все это дает предпосылки использования шины сообщений для организации взаимодействия между элементами представления.</p><p>Таким образом, на уровне инфраструктуры все функциональные связи между элементами представления осуществляются через шину сообщений (см. раздел <ac:link><ri:page ri:content-title="MessageBus" /></ac:link>). Правила публикации сообщений в шину и правила подписки на сообщения шины задаются в момент выполнения интерпретации данных представления, абсолютно прозрачно для прикладного разработчика. (Тем не менее, прикладной разработчик может свободно использовать функциональность шины сообщений для реализации своих задач.) В итоге, подобный подход позволил решить многие вышеуказанные проблемы, сохранив самодостаточность и независимость элементов представления.</p><h4>Источники данных<ac:structured-macro ac:name="anchor"><ac:parameter ac:name="">DataSources</ac:parameter></ac:structured-macro></h4><p>Каждое представление, безусловно, связано с какими-либо данными. В целях унификации и упрощения работы с данными был разработан единый программный интерфейс&nbsp;для работы с данными на уровне представления (см. раздел <ac:link><ri:page ri:content-title="BaseDataSource" /></ac:link>); также было выделено несколько типов источников данных (см. раздел <ac:link><ri:page ri:content-title="DataSource" /></ac:link>), покрывающих подавляющее количество задач с данными на уровне платформы. Источники данных создаются на этапе интерпретации метаданных представления, регистрируются в рамках экземпляра соответствующего представления и доступны через контекст представления.</p><h4>Контейнер элементов<ac:structured-macro ac:name="anchor"><ac:parameter ac:name="">LayoutPanel</ac:parameter></ac:structured-macro></h4><p>Контейнер элементов представления - визуальный элемент представления, который определяет способ визуального расположения своих дочерних элементов (см. раздел&nbsp;<ac:link><ri:page ri:content-title="LayoutPanel" /></ac:link>). Например,&nbsp;<ac:link><ri:page ri:content-title="TabPanel" /></ac:link>&nbsp;определяет панель закладок, в которых располагаются элементы представления, а&nbsp;<ac:link><ri:page ri:content-title="StackPanel" /></ac:link> располагает элементы представления в виде вертикального или горизонтального стека. Для представления можно определить только один контейнер элементов, но сам контейнер может содержать сколько угодно других контейнеров и элементов в любой их комбинации. Используя различные типы контейнеров, можно построить интерфейс практически любой сложности. Более того, при необходимости, можно свободно дополнять существующие типы контейнеров новыми типами, увеличив гибкость системы.</p><p>&nbsp;</p><p>&nbsp;</p>