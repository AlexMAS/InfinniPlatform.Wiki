---
layout: doc
title: "Message Queue: RabbitMq"
position: 
categories: 
tags: 
---

[RabbitMQ](https://www.rabbitmq.com/) - платформа, реализующая систему обмена сообщениями между компонентами программной системы на основе протокола [AMQP (Advanced Message Queuing Protocol)](http://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol).

#### Протокол AMQP

AMQP (Advanced Message Queuing Protocol) — открытый протокол для передачи сообщений между компонентами системы. Протокол основан на трех понятиях:

* Message - сообщение - единица передаваемых данных, основная его часть (содержание) никак не интерпретируется сервером, к сообщению могут быть прицеплены структурированные заголовки.
* Exchenge - точка обмена - приемник сообщений, осуществляющий распределение сообщений в одну или несколько очередей, но не отвечающий за сохранение сообщений; существует несколько типов точек обмена:  * fanout - сообщение предается в очередь, если она была связана (binding) с точкой обмена;
  * direct - сообщение передается в очередь, если ее ключ маршрутизации (routing key), указанный при отправке сообщения, совпадает с фильтром, который был указан в момент связывания (binding) очереди с точкой обмена;
  * topic - сообщение передается в очередь, если ее ключ маршрутизации (routing key), указанный при отправке сообщения, совпадает с фильтром, который был указан в момент связывания (binding) очереди с точкой обмена, причем фильтр может представлять шаблон;


* Queue - очередь сообщений - хранит сообщения до тех пор, пока они не будут получены потребителем (consumer).

 

Дополнительно определяются понятия:

* Consumer - потребитель (подписчик, обработчик, клиент) сообщений очереди.
* Acknowledge - сигнал подтверждения о том, что сообщение обработано, который посылает потребитель.
* Routing key - ключ маршрутизации, который указывается при отправке сообщения.
* Routing pattern - шаблон маршрутизации, который указывается в момент связывания.
* Binding - процесс связывания очереди и точки обмена.

#### Общая схема обмена

Сначала на стороне сервера создается точка обмена (exchange) и очередь (queue). При создании точки обмена указывается ее наименование и тип (fanout, direct, topic); при создании очереди указывается ее наименование и настройки, связанные с управлением сообщениями. Затем осуществляется связывание (bingding) очереди с точкой обмена. По завершению этого этапа получается инфраструктура, которая удовлетворяет нужному шаблону обмена между издателем (publisher) и потребителями (counsumer). Далее издатель осуществляет публикацию сообщений, а потребитель осуществляет прослушивание одной или нескольких очередей сообщений. В момент публикации издатель, как правило, сериализует пересылаемый объект в массив байт, прикрепляет к сообщению структурированный заголовок, в котором может указать, например, тип содержимого (Content Type), и вызывает метод публикации (publish), передавая ему сформированное сообщение и ключ маршрутизации (routing key). В момент прослушивания потребитель читает (dequeue) сообщение из прослушиваемого канала, десериализует содержимое принятого сообщения из массива байт в объект, возможно, анализируя заголовочную часть, после чего осуществляет обработку. Получив сообщение потребитель также может уведомить сервер о том, что сообщение обработано, послав сигнал подтверждения (acknowledge). Подтверждение может посылаться, как в ручном, так и в автоматическом режиме, в зависимости от того, как была объявлена (declare) очередь.

#### Кластеризация

RabbitMq поддерживает [кластеризацию](http://www.rabbitmq.com/clustering.html). Поскольку RabbitMq работает на базе Erlang-сервера, поэтому все сетевое взаимодействие между узлами кластера, на которых установлена шина, реализуется с помощью стандартных средств Erlang. Чтобы определить разрешено ли разным Erlang-серверам взаимодействовать друг с другом, они обмениваются хэшем пароля (который почему-то принято называть cookie, хотя с одноименным механизмом браузеров он ничего общего не имеет). Если хэши совпали, значит узлы могут взаимодействовать друг с другом. Таким образом, на всех узла кластера RabbitMq нужно прописать одинаковый хэш (см. инструкцию по развертыванию на официальном сайте).

Узлы в RabbitMQ кластере могут быть двух типов: работающие только в памяти и сохраняющие данные на диск. Так как состояние системы реплицируется между узлами кластера, в большинстве случаев достаточно иметь лишь 2-3 дисковых узла, а остальные избавить от необходимости работать с дисковой подсистемой для увеличения производительности. Важно понимать, что под состоянием системы здесь имеются ввиду лишь привязки и настройки сервера RabbitMq, каждая же очередь и хранящиеся в ней сообщения располагаются на одном конкретном узле, что приведет к потери части сообщений при сбое одного из серверов. Однако этот вопрос можно решить, включив репликацию для критически важных очередей. Такие очереди называются зеркальными (mirrored queues). Реплицирование очередей осуществляется по принципу "ведущий-ведомый" (master-slave), то есть сообщения публикуются на ведущий узел, а он реплицирует эти данные на все ведомые узлы. Если ведущий узел выходит из строя, один из ведомых узлов занимает его место.

Для хранения сообщений RabbitMq использует базу данных [Mnesia](http://en.wikipedia.org/wiki/Mnesia), которая представляет собой распределенное хранилище типа "ключ-значение", где в качестве ключа и значения выступают массивы байт.

#### Ссылки

[Официальный сайт RabbitMq](https://www.rabbitmq.com/)

[Спецификации AMQP](http://www.rabbitmq.com/specification.html)

[RabbitMQ tutorial 1 - Hello World](http://habrahabr.ru/post/149694/)

[RabbitMQ tutorial 1 - Очередь задач](http://habrahabr.ru/post/150134/)

 

 

